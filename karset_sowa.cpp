#include <iostream>
#include <KAR/KARoperator.h>//順番に気をつけろ(opencvとか　よりうしろ)
#include <Eigen/Dense>
#include <unistd.h>

using namespace Eigen;
int main(){
    KAROperator ks;
    VectorXd posq(8);//手先姿勢位置(rail,x,y,z,q_x,q_y,q_z,q_w)
    double time = 10.0;//移動時間
    // posq << 0.8,0.4,0.1,0.33,0,0,1,0;//(rail,x,y,z,q_x,q_y,q_z,q_w) 
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
    ks.setq(time,posq);
        sleep(10);        
//オイラー角度roll45.87978659666439,pitch-0.8672399888419537,yaw179.93611987740218


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.1381260183433962, 0.9903855902317626, -0.0004933033083495566
;

    ks.setq(time,posq);
        sleep(10);   
//オイラー角度roll15.879786596664388,pitch-0.8672399888419536,yaw179.93611987740218
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671723, 0.992388663760853, 0.0014834062078802515
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.006804606922133188, -0.37557215430690477, 0.9267620898544501, 0.0033590240424876874
;

    ks.setq(time,posq);
        sleep(10);     
//オイラー角度roll-14.120213403335606,pitch-0.8672399888419536,yaw179.93611987740218
}































//rail原点は0.0512052

// 0.311037 , 0.542007 , -0.000644983 , 0.21664 , 0.00752422 , 0.182187 , 0.983235 , -0.000837038
// 0.31,0.54,0.0,0.22,0,0,1,0

/*

テスト用の初期位置
    posq<<0.361794 , 0.462466 , -0.00141845 , 0.26669 , 0.00723724 , 0.369003 , 0.929397 , -0.00227366
;











ヨー軸を３０度づつマイナスのつもりがロール軸になっている
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);        


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.10781206412165328, 0.3746117574308317, 0.8901409118877824, 0.23599098925170714
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.20109511446306297, 0.33394335584747814, 0.798731133337985, 0.45833521211121275
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.28067386507920444, 0.2705172664306076, 0.6528891480168117, 0.6494446477000899
;

    ks.setq(time,posq);
        sleep(10);   

使用した関数
# クォータニオンからオイラー角を取得
roll, pitch, yaw = quaternion_to_euler(q_wxyz)

def quaternion_to_euler(q):
    # クォータニオンの要素
    w, x, y, z = q

    # オイラー角の計算
    roll = np.arctan2(2 * (w * x + y * z), 1 - 2 * (x**2 + y**2))
    pitch = np.arcsin(2 * (w * y - z * x))
    yaw = np.arctan2(2 * (w * z + x * y), 1 - 2 * (y**2 + z**2))

    # ラジアンを度に変換
    roll_deg = np.degrees(roll)
    pitch_deg = np.degrees(pitch)
    yaw_deg = np.degrees(yaw)


    return roll,pitch,yaw

# yaw軸の角度を30度ずつ5回引いたクォータニオンを出力
for _ in range(5):
    yaw -= np.radians(30)  # 10度をラジアンに変換して引く
    updated_quaternion = euler_to_quaternion(roll, pitch, yaw)
    #print("Updated Quaternion:", updated_quaternion)
    print(f"{updated_quaternion[1],updated_quaternion[2],updated_quaternion[3],updated_quaternion[0]}")















!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ロールー軸を30度マイナスのつまりがヨー軸になっている
!!!!!!!!!!!!!その逆も可能　ロール軸をプラスにしたらよー軸のプラスになった
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);        


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.1381260183433962, 0.9903855902317626, -0.0004933033083495566
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671723, 0.992388663760853, 0.0014834062078802515
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.006804606922133188, -0.37557215430690477, 0.9267620898544501, 0.0033590240424876874
;

    ks.setq(time,posq);
        sleep(10);   
使用した関数
# クォータニオンからオイラー角を取得
roll, pitch, yaw = quaternion_to_euler(q_wxyz)

def quaternion_to_euler(q):
    # クォータニオンの要素
    w, x, y, z = q

    # オイラー角の計算
    roll = np.arctan2(2 * (w * x + y * z), 1 - 2 * (x**2 + y**2))
    pitch = np.arcsin(2 * (w * y - z * x))
    yaw = np.arctan2(2 * (w * z + x * y), 1 - 2 * (y**2 + z**2))

    # ラジアンを度に変換
    roll_deg = np.degrees(roll)
    pitch_deg = np.degrees(pitch)
    yaw_deg = np.degrees(yaw)


    return roll,pitch,yaw

# yaw軸の角度を30度ずつ5回引いたクォータニオンを出力
for _ in range(5):
    roll -= np.radians(30)  # 10度をラジアンに変換して引く
    updated_quaternion = euler_to_quaternion(roll, pitch, yaw)
    #print("Updated Quaternion:", updated_quaternion)
    print(f"{updated_quaternion[1],updated_quaternion[2],updated_quaternion[3],updated_quaternion[0]}")




これは上から見ると逆時計回りに回転したら時計回りに回転するようになる
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);        


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.1381260183433962, 0.9903855902317626, -0.0004933033083495566
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671723, 0.992388663760853, 0.0014834062078802515
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.006804606922133188, -0.37557215430690477, 0.9267620898544501, 0.0033590240424876874
;

    ks.setq(time,posq);
        sleep(10);  

    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671723, 0.992388663760853, 0.0014834062078802515
;
    ks.setq(time,posq);
        sleep(10);   


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.1381260183433962, 0.9903855902317626, -0.0004933033083495566
;

    ks.setq(time,posq);
        sleep(10);   


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);     

    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671717, 0.992388663760853, 0.001483406207880251
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.13812601834339625, 0.9903855902317626, -0.000493303308349557
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.007186772376560993, 0.3897501411474452, 0.9208893754179508, -0.0024363950193376045
;

    ks.setq(time,posq);
        sleep(10);  
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.13812601834339625, 0.9903855902317626, -0.000493303308349557
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671717, 0.992388663760853, 0.001483406207880251
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);     
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!












ヨー軸を30度マイナスのつまりがヨー軸になっている
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);        


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007572474478578624, 0.1381260183433962, 0.9903855902317626, -0.0004933033083495566
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.007442124958986886, -0.12291116434671723, 0.992388663760853, 0.0014834062078802515
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.006804606922133188, -0.37557215430690477, 0.9267620898544501, 0.0033590240424876874
;

    ks.setq(time,posq);
        sleep(10);   
使用した関数
# クォータニオンからオイラー角を取得
roll, pitch, yaw = quaternion_to_euler(q_wxyz)

def quaternion_to_euler(q):
    # クォータニオンの要素
    w, x, y, z = q

    # オイラー角の計算
    roll = np.arctan2(2 * (w * x + y * z), 1 - 2 * (x**2 + y**2))
    pitch = np.arcsin(2 * (w * y - z * x))
    yaw = np.arctan2(2 * (w * z + x * y), 1 - 2 * (y**2 + z**2))

    # ラジアンを度に変換
    roll_deg = np.degrees(roll)
    pitch_deg = np.degrees(pitch)
    yaw_deg = np.degrees(yaw)


    return roll,pitch,yaw

# yaw軸の角度を30度ずつ5回引いたクォータニオンを出力
for _ in range(5):
    roll -= np.radians(30)  # 10度をラジアンに変換して引く
    updated_quaternion = euler_to_quaternion(roll, pitch, yaw)
    #print("Updated Quaternion:", updated_quaternion)
    print(f"{updated_quaternion[1],updated_quaternion[2],updated_quaternion[3],updated_quaternion[0]}")









ピッチ軸を20度マイナスにやるつもり
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.00718677 , 0.38975 , 0.92089 , -0.00243639
;

    ks.setq(time,posq);
        sleep(10);        


    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 , 0.16698777994710373, 0.38322759802299755, 0.9057264844264575, -0.07008013178034922
;

    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.32171494832384756, 0.3650608782551427, 0.8630435525253819, -0.13559451919947269
;
    ks.setq(time,posq);
        sleep(10);   
    posq<<0.302693 , 0.524271 , -0.00148314 , 0.28809 ,0.46666697079139013, 0.33580196843122306, 0.7941374790019322, -0.19698893576685755
;

    ks.setq(time,posq);
        sleep(10);  

# yaw軸の角度を10度ずつ5回引いたクォータニオンを出力
for _ in range(5):
    pitch -= np.radians(20)  # 10度をラジアンに変換して引く
    updated_quaternion = euler_to_quaternion(roll, pitch, yaw)
    #print("Updated Quaternion:", updated_quaternion)
    print(f"{updated_quaternion[1],updated_quaternion[2],updated_quaternion[3],updated_quaternion[0]}")
*/